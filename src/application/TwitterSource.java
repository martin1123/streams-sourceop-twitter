/* Generated by Streams Studio: May 5, 2014 2:31:39 PM PDT */
package application;


import java.util.ArrayList;

import org.apache.log4j.Logger;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamingOutput;

import twitter4j.*;
import twitter4j.conf.ConfigurationBuilder;

/**
 * A source operator that does not receive any input streams and produces new tuples. 
 * The method <code>produceTuples</code> is called to begin submitting tuples.
 * <P>
 * For a source operator, the following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
public class TwitterSource extends AbstractOperator {
	private final static String CONSUMER_KEY = "";
	private final static String CONSUMER_SECRET = "";
	private final static String ACCESS_TOKEN = "";
	private final static String ACCESS_SECRET = "";
	
	private final String FILTER = "filter";
	/**
	 * Thread for calling <code>produceTuples()</code> to produce tuples 
	 */
    private Thread processThread;
    private boolean filter;
    private String[] keywords;
    private TwitterStream twitterStream;

    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void initialize(OperatorContext context)
            throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
        super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        
        // Set parameters
        if (context.getParameterNames().contains(FILTER)) {
        	filter = true;
        	int numParam = context.getParameterValues(FILTER).size();
        	keywords = context.getParameterValues(FILTER).toArray(new String[numParam]);
        } else {
        	filter = false;
        }
        
        // If needed, insert code to establish connections or resources to communicate an external system or data store.
        // The configuration information for this may come from parameters supplied to the operator invocation, 
        // or external configuration files or a combination of the two.
        ConfigurationBuilder cb = new ConfigurationBuilder()
									.setDebugEnabled(true)
									.setOAuthConsumerKey(CONSUMER_KEY)
									.setOAuthConsumerSecret(CONSUMER_SECRET)
									.setOAuthAccessToken(ACCESS_TOKEN)
									.setOAuthAccessTokenSecret(ACCESS_SECRET);
		twitterStream = new TwitterStreamFactory(cb.build()).getInstance();
        
        /*
         * Create the thread for producing tuples. 
         * The thread is created at initialize time but started.
         * The thread will be started by allPortsReady().
         */
        processThread = getOperatorContext().getThreadFactory().newThread(
                new Runnable() {

                    @Override
                    public void run() {
                        try {
                            produceTuples();
                        } catch (Exception e) {
                            Logger.getLogger(this.getClass()).error("Operator error", e);
                        }                    
                    }
                    
                });
        
        /*
         * Set the thread not to be a daemon to ensure that the SPL runtime
         * will wait for the thread to complete before determining the
         * operator is complete.
         */
        processThread.setDaemon(false);
    }

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    	// Start a thread for producing tuples because operator 
    	// implementations must not block and must return control to the caller.
        processThread.start();
    }
    
    /**
     * Submit new tuples to the output stream
     * @throws Exception if an error occurs while submitting a tuple
     */
    private synchronized void produceTuples() throws Exception  {
    	StatusListener listener = createListener();    	
        twitterStream.addListener(listener);
        if (!filter) {
        	twitterStream.sample();
        } else {
        	FilterQuery fq = new FilterQuery();
        	fq.track(keywords);
        	twitterStream.filter(fq);
        }
        try {
			wait();
		} catch (InterruptedException e) {
			Logger.getLogger("Interrupted");
		}   
    }
    
    private StatusListener createListener() {
    	StatusListener listener = new StatusListener() {
            @Override
            public void onStatus(Status status) {        		
            	// New tuple
            	final StreamingOutput<OutputTuple> out = getOutput(0);
                OutputTuple tuple = out.newTuple();
        		
        		// Hashtags
                HashtagEntity[] hashtagEntities = status.getHashtagEntities();
        		ArrayList<String> hashtags = new ArrayList<String>();
        		for (int i=0;i<hashtagEntities.length;i++){
        			hashtags.add(hashtagEntities[i].getText());
        		}
        		
        		// data from status
        		String text = status.getText();
        		String username = status.getUser().getScreenName();
        		String language = status.getLang();// new Locale(status.getIsoLanguageCode()).getDisplayName();
        		
        		// Assign values to attributes
        		tuple.setString(tuple.getStreamSchema().getAttribute(0).getName(), username);
        		tuple.setString(tuple.getStreamSchema().getAttribute(1).getName(), language);
        		tuple.setList(tuple.getStreamSchema().getAttribute(2).getName(), hashtags);
        		tuple.setString(tuple.getStreamSchema().getAttribute(3).getName(), text);      		

        		// Submit the tuple
	        	try {
					out.submit(tuple);
				} catch (Exception e) {
					e.printStackTrace();
				}
            }
            @Override
            public void onDeletionNotice(StatusDeletionNotice statusDeletionNotice) {}
            @Override
            public void onTrackLimitationNotice(int numberOfLimitedStatuses) {}
            @Override
            public void onScrubGeo(long userId, long upToStatusId) {}
            @Override
            public void onStallWarning(StallWarning warning) {}
            @Override
            public void onException(Exception ex) {
                ex.printStackTrace();
            } 
        };
    	return listener;
    }

    /**
     * Shutdown this operator, which will interrupt the thread
     * executing the <code>produceTuples()</code> method.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
    	processThread.notify();
        if (processThread != null) {
            processThread.interrupt();
            processThread = null;
        }
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO: If needed, close connections or release resources related to any external system or data store.
        twitterStream.shutdown();
        // Must call super.shutdown()
        super.shutdown();
    }
}
